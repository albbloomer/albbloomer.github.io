{
    "componentChunkName": "component---src-templates-post-template-jsx",
    "path": "/dataflow20210719/",
    "result": {"data":{"markdownRemark":{"html":"<h2 id=\"시작\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91\" aria-label=\"시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작</h2>\n<p>나는 최근 DB에 대해 관심이 많다. 그래서 재밌게 공부하면서 나의 무기처럼 쓰기 위해 조금 깊게 팔 생각이다. 여러 책을 고민하면서 고른 책 4권 중에 <strong>MySQL 퍼포먼스 최적화</strong>에 공부를 시작해볼 것이다.</p>\n<h2 id=\"책을-보기-전-나는-지금-어떻게-생각하고-있는가\" style=\"position:relative;\"><a href=\"#%EC%B1%85%EC%9D%84-%EB%B3%B4%EA%B8%B0-%EC%A0%84-%EB%82%98%EB%8A%94-%EC%A7%80%EA%B8%88-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%9D%EA%B0%81%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EA%B0%80\" aria-label=\"책을 보기 전 나는 지금 어떻게 생각하고 있는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>책을 보기 전 나는 지금 어떻게 생각하고 있는가?</h2>\n<p>나는 최근에 쿼리 최적화를 하면서 계속 의문이 들었다. 최적화는 최적화인데 대체 어떻게 쿼리가 DB서버까지 가서 실행이 되고 쿼리가 실행이 되면 어떻게 이게 왜 최적화인지 궁금했다. 솔직히 아직까지는 잘모르겠다.\n<img src=\"https://images.velog.io/images/ggomjae/post/82848ff1-f2ae-4d4a-b5b9-5de5ae41a80b/image.png\" width=\"100%\" alt=\"\"></p>\n<blockquote>\n<p>그림에는 없지만 Web Application Server 왼쪽 부분에는 WebServer가 있으며 이 Web Server와 그림에 있는 Web Application Server, Db Server까지가 Server Side쪽이고 그 Web Server와 연결된 Http 로 통신하는 부분. 즉, 사용자쪽이 또 따로 있다. Client Side라 생각하면 된다.</p>\n</blockquote>\n<img src=\"https://images.velog.io/images/ggomjae/post/4b3deef6-1191-4b0a-a0da-c56b457bc1fa/image.png\" width=\"100%\" alt=\"\">\n<p>최근 생각날 때 마다 고민하면서 그린건데 솔직히 맞는지는 잘모르겠다. 서버엔진에서 그 받은 쿼리를 파싱하고 나서 스토리지 엔진은 <strong>인터페이스</strong>와 같은 역할로 DISK에 통신을 하는 것으로 알고 있다.</p>\n<p>즉, 나는 왜 이런 고민을 하냐면 인덱스에 대한 최적화를 공부하면서 최대한 DB에 적게 접근을 해야한다고 배웠고 그게 과연 Web Application Server에서 DB Server의 네트워크를 말하는건지 아니면 DB Server에서의 서버엔진에서 DISK로 가는 그러한 접근을 말하는 건지 이해를 할 수가 없었다.</p>\n<p>또 좀더 얘기를 해보자면 어떻게 보면 우리가 보는 쿼리는 고급언어이다. 이 고급언어를 TCP/IP로 통신을 하고 packet으로 오버헤드를 붙인 다음 프록시에 들렸다가 다시 DB Server로 쏘고 이제 여기서 MySQL 시스템이 있으며 여기에 서버엔진, 스토리지엔진이 있다고 생각하며 여기에 또한 데이터가 있는 DISK가 있다고 생각한다.</p>\n<p>그럼 이제 좀 더 나아가면 클러스터 인덱스 같은 경우에는 leaf 부분에 데이터가 이미 있기 때문에 이 DISK에 가지 않고 그렇기에 이 성능이 좋아진다는 것으로 이해하고 있다.</p>\n<p>즉, 지금 나의 머리가 복잡한 이유가 이 과정이다. 아니 이게 과연 인덱스가 필요로 한다고? 겨우 이걸로? 라는 생각으로 부터 지금 내가 생각하는 이 데이터 흐름이 과연 맞는지. 나는 이러한 생각들로 이 원론적인 부분에 들어가려한다. 물론 아직 책을 읽기 전이지만 답이 나올 것 같지는 않다. 답을 내려고 하는 것은 아니다. 물론 답이 나온다면 좋다. 이 포스팅은 나의 머리에 있는 지금 여러 흐름들을 정리하고자 쓰는 글이라고 생각하면 좋다.</p>\n<h2 id=\"mysql은-전체적으로-어떻게-생겼나\" style=\"position:relative;\"><a href=\"#mysql%EC%9D%80-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%9D%EA%B2%BC%EB%82%98\" aria-label=\"mysql은 전체적으로 어떻게 생겼나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL은 전체적으로 어떻게 생겼나?</h2>\n<p><strong>서버엔진</strong>, <strong> 스토리지 엔진</strong> 이 두가지를 알아야한다.</p>\n<blockquote>\n<p>서버엔진 : 클라이언트의 요청을 받아 SQL을 처리하는 DB 자체의 기능적인 역할</p>\n</blockquote>\n<p>스토리지 엔진 : 서버 엔진이 필요한 데이터를 물리 장치에서 가져오는 역할을 한다.</p>\n<p>자. 책에서 읽어보고 이해를 했을 때, 스토리지 엔진에서 DISK(물리 장치)에서 실제 데이터를 갖고 오는 것이 맞다.</p>\n<img src=\"https://images.velog.io/images/ggomjae/post/bdf47a05-b5e3-4577-9cea-b36a086da38b/image.png\" width=\"100%\" alt=\"\">\n<p>우선 여기까지는 내가 생각했던 것과 같다. 이 <strong>서버엔진</strong>은 DB가 SQL을 이해할 수 있도록 쿼리를 재구성하는 쿼리 파싱, 디스크나 메모리 같은 물리적인 저장장치와 통신하는 스토리지 엔진에 데이터를 요청하는 업무를 담당한다. 즉, 이 말을 조금 더 풀어서 생각하자면 <strong>스토리지 엔진</strong>이 데이터를 통신하기 위한 API 역할을 한다고 생각하면 쉬울 것 같다. 이것 또한 내가 생각했던 것과 같다.</p>\n<p>이제 여기서 가장 중요한 말을 하고 싶다.</p>\n<blockquote>\n<p><strong>스토리지 엔진에서 받아온 데이터를 사용자 요청에 맞게 처리하고 접근 제어, 쿼리 캐시, 옵티마이저 등의 역할을 수행한다. 사용자와 MySQL 사이에서 발생하는 데이터 처리 프로세스를 전부 담당한다고 생각하면 된다. </strong></p>\n</blockquote>\n<p>이해가 되는가? 조금 더 이해하기 쉽도록 예를 보여주자면 Jojn, Group By, Order By, Function/Procedure, Trigger 와 같은 것 또한 <strong>서버엔진</strong>에서 모두 맡아서 한다고 생각하면 된다.</p>\n<p>이제 서버엔진을 봤으니 <strong>스토리지 엔진</strong>을 볼 차례다. 이 스토리지 엔진은 <strong>물리적인 저장장치에서 테이터를 읽어오는 역할</strong>을 한다. 이게 되게 웃긴 것은 다른 DBMS와는 다르게 플러그인 처럼 작동하기 때문에 여러 종류의 스토리지 엔진을 간단하게 설치하여 바로 사용할 수 있다. 예를 들면 InnoDB, MyISAM과 같은 엔진이 있다.</p>\n<h2 id=\"mysql에서-스토리지-엔진이란-무엇인가\" style=\"position:relative;\"><a href=\"#mysql%EC%97%90%EC%84%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"mysql에서 스토리지 엔진이란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL에서 스토리지 엔진이란 무엇인가?</h2>\n<p>MySQL은 이러한 다양한 엔진으로 부터 다른 DBMS보다도 강력하다고 할 수 있다. 확장성과 유연함에서 말이다. 우리는 다른 엔진보다도 InnoDB를 엔진을 많이쓴다. 이유는 무엇일까?</p>\n<p>InnoDB는 <strong>MySQL에서 유일하게 트랜잭션을 지원하는 스토리지 엔진이다.</strong> 그렇기에 많이 쓴다. 또한 그 경쟁자 MyISAM 같은 경우는 인덱스만 메모리에 올리지만 <strong>InnoDB는 인덱스와 데이터를 모두 올린다는 것이 가장 성능에 차이가 있다는 것</strong>. 즉, InnoDB_Buffer_Pool_Size가 DB성능에 큰 영향을 주기도 한다.</p>\n<p>그럼 너무나도 당연한게 InnoDB에서는 클러스터 인덱스를 사용할 수 있지만 MyISAM같은 경우는 클러스터 인덱스를 지원하지 않는다.</p>\n<p><strong>Archive 스토리지 엔진</strong>??\n나는 이 책을 읽으면서 처음으로 들어본 엔진이다. 책을 읽으면서 너무 쓸데없는 부분이 있거나 쓰지 않는 엔진같은 경우 정리를 하지 않지만 이 엔진 같은 경우에는 나중에라도 한번은 쓸 수 있을 것같아서 정리를 한다. 이 엔진 같은 경우에는 <strong>로그 수집에 적합한 스토리지 엔진</strong>이다.  데이터가 메모리상에서 압축되고 !! 이 상태로 디스크에 저장되기에 행 단위 잠금이 가능하고 UPDATE, DELETE를 사용할 수 없기 때문에 굉장히 로그와 같은 통계 프로젝트에 적합하다. 즉, 압축을 하므로 디스크에 대한 용량 또한 많이 줄일 수 있어서 좋다.</p>\n<h2 id=\"mysql은-데이터를-어떻게-처리-할까\" style=\"position:relative;\"><a href=\"#mysql%EC%9D%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B2%98%EB%A6%AC-%ED%95%A0%EA%B9%8C\" aria-label=\"mysql은 데이터를 어떻게 처리 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MYSQL은 데이터를 어떻게 처리 할까?</h2>\n<p>MySQL은 SQL을 병렬 처리하지 않는다... 음.. 우선 병렬처리는 하지 않는다. 모든 SQL을 단일 코어에서 처리한다.</p>\n<p>우선 팩트만 말하면 <strong>MySQL 입장에서는 CPU 코어 개수를 늘리는 Scale-Out 보다는 단위 처리량이 좋은 CPU로 Scale-Up 하는 것이 훨씬 좋다.</strong> 이게 팩트다.</p>\n<p>MySQL의 Join은 항상 <strong>Nested Loop Join</strong> 알고리즘으로 처리한다.\n이러한 Nested Loop Join 같은 경우에는 처리할 데이터가 적어지면 수행 속도가 빠르지만 테이블 A나 테이블 B 중 하나라도 연산해야 할 데이터가 많아지면 쿼리 효율이 기하급수적으로 떨어진다.</p>\n<p>이제 여기서 내가 알고 있던 지식은 드라이빙 테이블에서 드라이븐 테이블로 접근할 때, 드라이븐 테이블에서 인덱스가 없으면 풀스캔이 난다는 지식만 알고 있었고 만약 그렇지 않으면 풀스캔을 한다는 것만 알고 있었다. 이 책을 읽어보고 여기서 조금 더 추가를 하자면 3개의 for 반복문이 있고 하나의 테이블이 더 생성되며, 만약 드라이븐 테이블에서 마땅한 index가 없으면 3번째 테이블을 이용한 풀스캔을 한다는 것을 알았다.</p>\n<p>그리고 조금 더 나아가자면 <strong>Block Nested Loop Join</strong>을 알았다. 즉, DB 내부에서 조금 더 성능을 높이기 위해서 테이블 조인 시 필요한 데이터를 일시적으로 메모리에 저장하여 효율적으로 데이터에 접근하는 것!</p>\n<p>우선 이 부분은 읽어봐도 이해가 되지는 않지만, 드라이븐 테이블에 접근하는 빈도수를 더 적게 해주면서 성능이 좋아지는 것같다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>오늘 쉬는 날이기도 해서 가볍게 DB에 대한 책을 읽어보기 시작했다. 이 책은 작다. 그리고 페이지수도 적다. 출, 퇴근 시간에 버스에서 읽으려고 했는데 멀미가 나서 그 동안 읽지 못했다. 무튼.. 결론은 굉장히 작은 책이지만 재밌었다.</p>\n<hr>\n<p><strong>참고</strong> : 실무 예제로 다가가는 MySQL 쿼리작성 MySQL 퍼포먼스 최적화 - 성동찬, 한빛미디어</p>","timeToRead":5,"excerpt":"시작 나는 최근 DB에 대해 관심이 많다. 그래서 재밌게 공부하면서 나의 무기처럼 쓰기 위해 조금 깊게 팔 생각이다. 여러 책을 고민하면서 고른 책 4권 중에 MySQL…","frontmatter":{"title":"MySQL의 데이터 흐름 및 특징  - 답이 아닌 책을 읽으면서 나의 머리에 있는 흐름을 정리한 글","date":"2021-07-19T22:19:00Z","categories":["db"],"tags":["mysql","db"],"description":"this is a description","keywords":"pig","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#888888","images":{"fallback":{"src":"/static/e07bf3b6a654ab0bfb80d32de2e3ba49/7ecdb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-17%20%EC%98%A4%ED%9B%84%201.36.11.png","srcSet":"/static/e07bf3b6a654ab0bfb80d32de2e3ba49/7ecdb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-17%20%EC%98%A4%ED%9B%84%201.36.11.png 660w","sizes":"660px"},"sources":[{"srcSet":"/static/e07bf3b6a654ab0bfb80d32de2e3ba49/37d7e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-17%20%EC%98%A4%ED%9B%84%201.36.11.webp 660w","type":"image/webp","sizes":"660px"}]},"width":660,"height":339}}}},"fields":{"slug":"/dataflow20210719/","date":"2021-07-19T22:19:00.000Z"}}},"pageContext":{"slug":"/dataflow20210719/","nexttitle":"Where 조건에 대한 이해","nextslug":"/lke20210630/","prevtitle":"MySQL TimeZone 설정 - serverTimezone=Asia/Seoul 로 수정할 때","prevslug":"/timezone20210719/","tagList":["infra","cache","docker","crawl","spring","java","theory","git","mysql","db"],"categoryList":["redis","docker","java","spring","theory","db"],"latestPostEdges":[{"node":{"fields":{"slug":"/redisinfra20231124/"},"frontmatter":{"template":"post","title":"redis 구성 - 단일, 레플리케이션, 센티넬","tags":["infra","cache"],"categories":["redis"],"date":"2023-11-24T18:31:00Z"}}},{"node":{"fields":{"slug":"/docker20231113/"},"frontmatter":{"template":"post","title":"도커 overlay 용량을 정리해보자.","tags":["docker"],"categories":["docker"],"date":"2023-11-13T22:31:00Z"}}},{"node":{"fields":{"slug":"/crawl20231020/"},"frontmatter":{"template":"post","title":"크롤 버전 이슈","tags":["crawl"],"categories":["java"],"date":"2023-10-20T22:31:00Z"}}},{"node":{"fields":{"slug":"/cachelocalglobal20230523/"},"frontmatter":{"template":"post","title":"[1] 서비스 캐싱 - Local, Global","tags":["spring","java","cache"],"categories":["spring"],"date":"2023-05-23T22:31:00Z"}}},{"node":{"fields":{"slug":"/solid20220501/"},"frontmatter":{"template":"post","title":"객체 지향 설계 5원칙 - SOLID","tags":["theory"],"categories":["theory"],"date":"2022-05-01T22:31:00Z"}}},{"node":{"fields":{"slug":"/jpa120220421/"},"frontmatter":{"template":"post","title":"JPA 영속성 관리","tags":["java","spring"],"categories":["spring"],"date":"2022-04-21T22:31:00Z"}}},{"node":{"fields":{"slug":"/collector20220303/"},"frontmatter":{"template":"post","title":"Collect, Collector, Collectors 정리","tags":["java"],"categories":["java"],"date":"2022-03-03T22:31:00Z"}}},{"node":{"fields":{"slug":"/gitbasic20220218/"},"frontmatter":{"template":"post","title":"GIT 에 대한 그림 이해","tags":["git"],"categories":["theory"],"date":"2022-02-18T22:31:00Z"}}}]}},
    "staticQueryHashes": []}
<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[율로그]]></title><description><![CDATA[A GatsbyJS Blog Template for blogging purpose.]]></description><link>https://gb-template.netlify.com</link><image><url>https://gb-template.netlify.com/logos/logo-512x512.png</url><title>율로그</title><link>https://gb-template.netlify.com</link></image><generator>Gatsby Blog Template</generator><lastBuildDate>Sat, 18 Nov 2023 10:24:40 GMT</lastBuildDate><atom:link href="https://gb-template.netlify.com/rss.xml" rel="self" type="application/rss+xml"/><copyright><![CDATA[©Yul, Built with Gatsby-blog-template]]></copyright><item><title><![CDATA[Mysql Query Between 과 >=, <= 성능 차이 비교 ( 더미데이터 50만 )]]></title><description><![CDATA[현재 친절한 SQL 튜닝을 읽고 있습니다. 그러던 중 Between And 과 Where 부등호 사이의 성능 차이가 있다는 말을 들었고 직접 Test를 진행했습니다. 2021-04-20 Stack Over flow…]]></description><link>https://gb-template.netlify.com/between20210729/</link><guid isPermaLink="false">https://gb-template.netlify.com/between20210729/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Thu, 29 Jul 2021 20:31:00 GMT</pubDate><content:encoded>&lt;p&gt;현재 친절한 SQL 튜닝을 읽고 있습니다. 그러던 중 Between And 과 Where 부등호 사이의 성능 차이가 있다는 말을 들었고 직접 Test를 진행했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2021-04-20&lt;/strong&gt; Stack Over flow, 선배님의 의견 그리고 나의 생각으로 다시 생각을 해보았을 때, 실험에 대한 실행 수가 매우 적었으며, 단지 문법만 다른 것일 뿐 explain도 같고 근거가 없기 때문에 서로 같은 것이라고 결론을 내린다. 또한, 부등호 같은 경우에는 DBMS에 종속적이지 않다는 장점이 있다는 것과 DBMS별로 성능에 대한 미세한 차이가 있을 수 있다는 결론을 내리고 글을 끝낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;현재 친절한 SQL 튜닝을 읽고 있다. 책을 보고 있는 도중에 between, where, in 등의 의문이 들었고 많이 질문을 하면서 얘기하는 도중에 between and 과  &gt;=, &amp;#x3C;= 의 성능차이가 있다는 것을 들었다. 책에도 나오지 않았기에 의아했고 50만개의 더미데이터를 이용해서 직접 테스트를 하려한다. 과거 1년 동안은 &lt;strong&gt;그렇구나&lt;/strong&gt; 하고 끝냈다면 이제는 귀찮더라도... 해봐야지&lt;/p&gt;
&lt;h2 id=&quot;multi-module---db-entity-setting&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#multi-module---db-entity-setting&quot; aria-label=&quot;multi module   db entity setting permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Multi Module - DB Entity Setting&lt;/h2&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/f02c079b-be3d-4463-a465-3ec6b130c828/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;더미데이터를 넣기전에 테스트를 할 Entity를 설정했다. 여기서 AccessLeve, GenerationType 같은 경우는 따로 포스팅을 할 계획이다.&lt;/p&gt;
&lt;h2 id=&quot;약-50만개-데이터-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%95%BD-50%EB%A7%8C%EA%B0%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;약 50만개 데이터 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;약 50만개 데이터 생성&lt;/h2&gt;
&lt;p&gt;딱히 없다. 어느 정도의 Data를 만들고 2018년부터 현재까지 데이터를 하루 단위로 넣어주었다.&lt;br&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/1d1cd465-1ca2-4728-bef2-a5b4c5ef4919/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;test---explain&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#test---explain&quot; aria-label=&quot;test   explain permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TEST - Explain&lt;/h2&gt;
&lt;p&gt;첫 번째로 해볼 것은 Explain 이다. Explain을 우선적으로보고 차이점이 있는지 확인을 하자.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/798cf05b-d650-4e6e-a8c5-9a6f995ee46e/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Between Explain&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/6f3fb711-fd9c-4df5-98c0-187819ea4fbc/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;where 부등호 Explain&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;test---성능-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#test---%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;test   성능 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TEST - 성능 테스트&lt;/h2&gt;
&lt;p&gt;우선 전제로 두어야할 것은 인덱스와 Where절에 DATE TYPE을 고려하지 않고 모든 조건에 맞게끔 TEST를 하였다. 우선 부등호 부터 성능조사를 해보자.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/77df79b3-0004-4eb6-8531-996495eaedeb/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where 부등호&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/0c3e5bac-0f5f-4751-979f-4b9a3d378794/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
혹여나 캐시를 확인하자. 캐시가 없다는 것을 확인했다. 곧바로 Between으로 성능을 테스트하자
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/fe230757-0e9d-415f-9ae9-099869b4a945/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Between&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결과적으로 확실히 Between 보다는 Where 을 이용하여 부등호를 사용해서 조회하는 것이 빠르다. 왜이럴까?&lt;/p&gt;
&lt;h2 id=&quot;왜-이런-결과가-나오는-것일까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%9C-%EC%9D%B4%EB%9F%B0-%EA%B2%B0%EA%B3%BC%EA%B0%80-%EB%82%98%EC%98%A4%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;왜 이런 결과가 나오는 것일까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;왜 이런 결과가 나오는 것일까?&lt;/h2&gt;
&lt;p&gt;우선 구글링에 검색해보면 CPU Cycle일 것이라는 답변이 있다. 근데 최근 친절한 SQL 튜닝에서 이런 부분에 대해서 좀 세세하게 나온것이 있어서 확인해봤다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/7129f0a0-cfed-4c59-a022-1ce3dcf7f9f9/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;where 부등호&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;물론 이게 정확한 예시가 아닐 수 있다. 정확하게 부등호만 나온 부분을 못찾았기에. 스캔 범위만 우선적으로 확인해봤다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/4da5e7d5-ae8d-4c59-a490-db6dba426a01/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Between&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 사진의 공통점은 범위 스캔하는 부분이 같다는 것이다. 어찌보면 당연하다. Explain 결과도 같으니까.
눈에 보이지 않은 내부적인 부분이라 생각한다. 그게 CPU Cycle때문이라는 것이다.&lt;/p&gt;
&lt;h2 id=&quot;끝내며&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%81%9D%EB%82%B4%EB%A9%B0&quot; aria-label=&quot;끝내며 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;끝내며&lt;/h2&gt;
&lt;p&gt;결과론적으로는 Between 보다는 Where 부등호가 좀 더 좋은 선택지라는 것이다. 그리고 그 이유는 CPU Cycle이라는 확신을 내리지 못하는 답이다. 이부분에 대해서는 좀더 찾아보고 포스팅을 좀 더 추가를 해야할 것같다. 그래도 값진 경험인 것은 직접 더미데이터를 만들었으며, Explain을 통해 결과를 확인했고 CPU Cycle이라는 결과가 정말 맞는지 직접 책을 찾아보고 Scan 범위를 확인했다는 점에서 이미 나는 점차 성장하고 있다는 것을 느끼며 마무리한다.&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item><item><title><![CDATA[스토리지 엔진 레벨에서의 접근법]]></title><description><![CDATA[시작 책에 있는 순서로 보면 '스토리지 엔진 레벨에서의 접근법'은 맨 마지막에 있는 목차이다. 그럼에도 불구하고 이 마지막 부분을 먼저 공부하는 이유는 페이지 수가 적기 때문이다.  오늘은 충전도 같이 해줘야하는 날이기에 타협을 봤다. InnoDB 가 짱? 다른 스토리지 엔진은? 무조건 InnoDB…]]></description><link>https://gb-template.netlify.com/index20210721/</link><guid isPermaLink="false">https://gb-template.netlify.com/index20210721/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Wed, 21 Jul 2021 22:31:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;책에 있는 순서로 보면 &apos;스토리지 엔진 레벨에서의 접근법&apos;은 맨 마지막에 있는 목차이다. 그럼에도 불구하고 이 마지막 부분을 먼저 공부하는 이유는 페이지 수가 적기 때문이다.  오늘은 충전도 같이 해줘야하는 날이기에 타협을 봤다.&lt;/p&gt;
&lt;h2 id=&quot;innodb-가-짱-다른-스토리지-엔진은&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#innodb-%EA%B0%80-%EC%A7%B1-%EB%8B%A4%EB%A5%B8-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84%EC%9D%80&quot; aria-label=&quot;innodb 가 짱 다른 스토리지 엔진은 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;InnoDB 가 짱? 다른 스토리지 엔진은?&lt;/h2&gt;
&lt;p&gt;무조건 InnoDB가 짱일까? 책을 보며 확인해보자. InnoDB는 행단위 잠금으로 데이터를 처리한다.
우선 여기서 말하는 &lt;strong&gt;&apos;잠금&apos;&lt;/strong&gt;이라는 것은 여러 트랜잭션이 동시에 동일한 Data에 접근하는 경우에 서로의 연산들이 동시성에 문제가 될 수 있으므로 간섭하지 않게 제어하는 기법이다.&lt;/p&gt;
&lt;p&gt;MySQL InnoDB 같은 경우에는 행단위 잠금이므로 여러 세션의 동시 쓰기 엑세를 지원하고 그러므로 다중 사용자, 동시성이 높은 OLTP 애플리케이션에 적합하다고 할 수 있다.&lt;/p&gt;
&lt;p&gt;여기서 또 &lt;strong&gt;&apos;OLTP&apos;&lt;/strong&gt;는 여러 사용자가 실시간으로 DB Data를 갱신, 조회하는 단위 작업 처리하는 방식이다.&lt;/p&gt;
&lt;p&gt;더 나아가 InnoDB 같은 경우에는 &lt;strong&gt;인덱스와 더불어 데이터까지 버퍼풀에 저장하기 때문에 모든 데이터가 메모리에 있으면 디스크를 읽지 않아도 되므로 강력한 성능&lt;/strong&gt;을 발휘한다.&lt;/p&gt;
&lt;p&gt;뭐 아무튼.. InnoDB가 이러한 장점이 있다면 &lt;strong&gt;단점&lt;/strong&gt; 또한 존재하는데 그 단점을 말하고자 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 인덱스와 데이터 모두 메모리에 적재되므로 메모리 사용 효율에 좋지 않다.&lt;br&gt;
&lt;strong&gt;2.&lt;/strong&gt; 보조 인덱스 같은 경우도 데이터를 찾아가는 Key를 갖고 있기에 인덱스 사이즈 자체가 커질 수 있으므로 메모리 사용 효율에 좋지 않다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 단점의 결론은 &lt;strong&gt;메모리&lt;/strong&gt; 때문에 &lt;strong&gt;로그 수집&lt;/strong&gt;에 대한 용도로 InnoDB를 쓰는 것은 바보같은 짓이다.&lt;/p&gt;
&lt;p&gt;그럼 로그를 수집하는 프로젝트에서 어떤 스토리지엔진을 쓰면 좋을까? 전에 쓰던 글에도 써있지만 &lt;strong&gt;Archive 스토리지 엔진&lt;/strong&gt;은 행 단위 잠금이며 데이터를 압축하며 디스크에 저장하기 때문에 적합한 스토리지 엔진이다. 다만, 인덱스를 생성할 수 없으며 UPDATE/DELETE를 사용할 수없기에 이런 부분에서의 기능이 필요하다면 &lt;strong&gt;MyISAM&lt;/strong&gt;을 쓰는 것을 권장한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;같은 경우는 행단위 잠금이 아니라 테이블 단위 잠금이기에 동시성에 문제가 생기므로 동시 서비스에는 적합하지 않지만, 저사양 서버에서 사용하기 위해 고안된 스토리지 엔진이기에 &lt;strong&gt;메모리&lt;/strong&gt; 측면에서 좋은 선택지가 될 수 있다.&lt;/p&gt;
&lt;p&gt;즉, 정리해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MyISAM vs Archive&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정말 로그 수집만을 위한 프로젝트인 경우 ( UPDATE/DELETE  가 필요로 없는 경우 ) &lt;strong&gt;Archive 스토리지 엔진&lt;/strong&gt;을 쓰고 만약, 로그 수집이지만 UPDATE/DELETE가 필요하다면 &lt;strong&gt;MyISAM 스토리지 엔진&lt;/strong&gt;을 쓰는 것이 좋은 선택지다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InnoDB vs MyISAM &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 수집이 목적이 아니며 읽기 전용이면 &lt;strong&gt;MyISAM 스토리지 엔진&lt;/strong&gt;을 쓰고 그것이 아니라면 &lt;strong&gt;동시처리, 트랜잭션&lt;/strong&gt;을 고려해야 하는 경우 &lt;strong&gt;InnoDB&lt;/strong&gt;. 그것이 아니라면 &lt;strong&gt;MyISAM&lt;/strong&gt;을 쓰면 된다.&lt;/p&gt;
&lt;h2 id=&quot;innodb를-사용한다면-barracuda-파일-포맷-고려해보자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#innodb%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4%EB%A9%B4-barracuda-%ED%8C%8C%EC%9D%BC-%ED%8F%AC%EB%A7%B7-%EA%B3%A0%EB%A0%A4%ED%95%B4%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;innodb를 사용한다면 barracuda 파일 포맷 고려해보자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;InnoDB를 사용한다면 Barracuda 파일 포맷 고려해보자.&lt;/h2&gt;
&lt;p&gt;우선 전제는 MySQL 5.5 버전이상이여야한다. InnoDB 파일 포맷인 &lt;strong&gt;Barracuda을 사용한다면 데이터 저장 공간을 크게 절약&lt;/strong&gt;할 수 있다. Dynamic, Compressed 로 저장할 수 있는 형식이 있는데 이 부분은 깊게 다루지 않겠다. 간단하게 말하자면 데이터를 압축하며 저장 공간을 절약할 수 있는 느낌만 알고 가자. &lt;strong&gt;EX.&lt;/strong&gt; 버퍼풀이 24GB지만 내부적으로 40GB처럼 사용할 수있다는 것.&lt;/p&gt;
&lt;p&gt;책에 나와있는 필자의 경험에는 Amazon RDS에서 Barracuda Format을 이용하여 디스크 사용 효율을 높인 경험이 있다고 한다. 즉, 메모리가 무궁무진하며 되게 크다면 사용할 일이 없겠지만, &lt;strong&gt;제한된 메모리 크기를 극복하고자 한다면 Barracuda&lt;/strong&gt;를 고려해볼만 하다.&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B0&quot; aria-label=&quot;마치며 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치며&lt;/h2&gt;
&lt;p&gt;항상 우리는 공부하면서 MySQL은 곧 InnoDB와 같은 느낌으로 공부를 했다. 너무나도 당연시되는 느낌이랄까. 아무 문제 없는 평범한 일상속에서의 실력이 아닌 예상하지 못한 상황에서 실력을 발휘하는 것이 진정한 개발자라고 생각한다. 지금 나의 기준 그리고 나의 위치에서 성능에 있어서 문제가 생겼을 때, &lt;strong&gt;InnoDB가 아닌 다른 스토리지 엔진을 쓰면 되지않을까? &lt;/strong&gt; 하는 생각이 나게끔 공부를 하는 것은 좋은 방향성이라고 생각한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt; : 실무 예제로 다가가는 MySQL 쿼리작성 MySQL 퍼포먼스 최적화 - 성동찬, 한빛미디어&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item><item><title><![CDATA[MySQL TimeZone 설정 - serverTimezone=Asia/Seoul 로 수정할 때]]></title><description><![CDATA[시작 회사 신입과제를 할 때, 의외로 TimeZone에서 많은 시간을 보냈습니다. 회사 코드, DB에는 설정을 하고 계속 개발을 시작하였지만, 제가 정리하는 개인 프로젝트에는 설정이 안되어있기에 설정을 하려고 합니다. UTC(Coordinated Universal Time:세계 협정시)는 예전의 GMT(Greenwich…]]></description><link>https://gb-template.netlify.com/timezone20210719/</link><guid isPermaLink="false">https://gb-template.netlify.com/timezone20210719/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Mon, 19 Jul 2021 22:31:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;회사 신입과제를 할 때, 의외로 TimeZone에서 많은 시간을 보냈습니다. 회사 코드, DB에는 설정을 하고 계속 개발을 시작하였지만, 제가 정리하는 개인 프로젝트에는 설정이 안되어있기에 설정을 하려고 합니다.&lt;/p&gt;
&lt;p&gt;UTC(Coordinated Universal Time:세계 협정시)는 예전의 GMT(Greenwich Mean Time)가 표준화 된 것입니다. KST(대한민국)는 UTC +9:00 인 값입니다.&lt;/p&gt;
&lt;p&gt;이제 해야할 것은 Intellij에서 JDBC URL의 ServiceTimeZone과 Mysql DB 서버와 TimeZone을 일치시켜 UTC가 아닌 KST로 수정하려합니다.&lt;/p&gt;
&lt;h2 id=&quot;intellij-설정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#intellij-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;intellij 설정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Intellij 설정&lt;/h2&gt;
&lt;p&gt;DB를 연결하는 yml 에서 Timezone을 수정합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;url&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; jdbc&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;mysql&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;localhost&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;basic&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;serverTimezone&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;UTC&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;characterEncoding&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;UTF&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존에 Timezone이 UTC 였다면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;url&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; jdbc&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;mysql&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;localhost&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3306&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;basic&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;serverTimezone&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Asia&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Seoul&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;characterEncoding&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;UTF&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Asia / Seoul 로 변경해줍니다.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/d7e972b8-0722-47ab-a36b-88a809d8f051/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;mysql-asiaseoul-set&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql-asiaseoul-set&quot; aria-label=&quot;mysql asiaseoul set permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MySQL Asia/Seoul Set&lt;/h2&gt;
&lt;p&gt;만약 JDBC URL만 KST로 수정하고 MySQL에는 UTC로 그대로 냅두면, 계속 UTC로 남아있거나, 에러가 났을 겁니다. 그 부분을 방지하고자 같이 동기화를 시켜줍니다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/39a22014-2501-4d18-9656-0a067ebd3e77/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;Mysql WorkBench를 이용합니다. 우선 사진과 같이 현재 global.time_zone 과 session.time_zone을 확인합니다. 설정이 아닌 default 값으로 SYSTEM 으로 설정이 되어있습니다. 그럼 Set을 통해 변경해보겠습니다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/fa701b6f-fcc9-4905-98eb-e9ae4d9e4b25/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;여기서 만약 에러가 아닌 곧바로 셋팅이 된다면, 끝난거지만 보편적으로는 안될겁니다.&lt;/p&gt;
&lt;p&gt;그 다음 단계는 Asia/Seoul을 셋팅하기위해 URL에 접속합니다.
&lt;a href=&quot;https://dev.mysql.com/downloads/timezones.html&quot;&gt;https://dev.mysql.com/downloads/timezones.html&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/2340faf0-24cf-4996-bea0-82d1e18f4270/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
접속 후에, Window OS인 유저분들은 해당 빨간 네모칸에 있는 부분을 다운로드하면 됩니다. ( 5.7+ 이라는 것은 Mysql Version 입니다. )
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/9d00f39c-fabc-4c45-85db-2ab5ac42ce83/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;다운로드 후, 클릭을 하면 사진과 같은 압출 풀기가 나오고 더블클릭 후, Mysql Bench를 곧바로 열어주면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/919f2636-ff32-4f24-9315-39cda1aa4d00/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;use mysql를 우선적으로 실행을 시킵니다. 만약 mysql Cli인 경우 password를 치면 곧바로 복붙하면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/286a9916-22a8-4cb3-be84-83615f02a00d/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;이제 마지막 단계입니다. 아까와는 다르게 TimeZone이 설정이 잘됩니다.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/05e52f96-fc73-49c6-b9be-c4c67bcfa56e/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;mysql-server-myini-설정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql-server-myini-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;mysql server myini 설정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mysql Server my.ini 설정&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;\&lt;span class=&quot;token class-name&quot;&gt;ProgramData&lt;/span&gt;\&lt;span class=&quot;token class-name&quot;&gt;MySQL&lt;/span&gt;\&lt;span class=&quot;token class-name&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8.0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해당 경로를 찾아들어가서 my.ini를 찾고 설정을 해줍니다. txt 마지막 줄에&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;time&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;zone&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Asia&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Seoul&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 추가해주시면 됩니다. 하지만 분명히 경고창이 뜰겁니다.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/8cb3927d-fa87-45ba-9440-05d7b3f51ee1/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/dcd0c5fb-959f-489c-a87e-2d45c3176495/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;my.ini의 오른쪽 마우스 클릭을 하고 보안 탭에 들어가서 권한을 변경해줍니다. 그리고 다시한번 변경해주면 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;서버-재구동&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%B2%84-%EC%9E%AC%EA%B5%AC%EB%8F%99&quot; aria-label=&quot;서버 재구동 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서버 재구동&lt;/h2&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/b2e72390-bd61-44ca-97c5-b0f9eab9be4c/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;밑에 &apos;검색하려면 여기에 입력하시오.&apos; 부분에 &lt;strong&gt;서비스&lt;/strong&gt;을 입력하여 서비스를 실행시키고 MySQL80을 찾아 서버 재구동을 시킵니다.&lt;/p&gt;
&lt;h2 id=&quot;결과&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B2%B0%EA%B3%BC&quot; aria-label=&quot;결과 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;결과&lt;/h2&gt;
&lt;p&gt;다시 한번 TimeZone을 확인하면 짜잔! 제대로 나오는 것을 볼수있습니다.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/48ab99b5-fb96-4558-bacf-23d94d3e665f/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item><item><title><![CDATA[MySQL의 데이터 흐름 및 특징  - 답이 아닌 책을 읽으면서 나의 머리에 있는 흐름을 정리한 글]]></title><description><![CDATA[시작 나는 최근 DB에 대해 관심이 많다. 그래서 재밌게 공부하면서 나의 무기처럼 쓰기 위해 조금 깊게 팔 생각이다. 여러 책을 고민하면서 고른 책 4권 중에 MySQL…]]></description><link>https://gb-template.netlify.com/dataflow20210719/</link><guid isPermaLink="false">https://gb-template.netlify.com/dataflow20210719/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Mon, 19 Jul 2021 22:19:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;나는 최근 DB에 대해 관심이 많다. 그래서 재밌게 공부하면서 나의 무기처럼 쓰기 위해 조금 깊게 팔 생각이다. 여러 책을 고민하면서 고른 책 4권 중에 &lt;strong&gt;MySQL 퍼포먼스 최적화&lt;/strong&gt;에 공부를 시작해볼 것이다.&lt;/p&gt;
&lt;h2 id=&quot;책을-보기-전-나는-지금-어떻게-생각하고-있는가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B1%85%EC%9D%84-%EB%B3%B4%EA%B8%B0-%EC%A0%84-%EB%82%98%EB%8A%94-%EC%A7%80%EA%B8%88-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%9D%EA%B0%81%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EA%B0%80&quot; aria-label=&quot;책을 보기 전 나는 지금 어떻게 생각하고 있는가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;책을 보기 전 나는 지금 어떻게 생각하고 있는가?&lt;/h2&gt;
&lt;p&gt;나는 최근에 쿼리 최적화를 하면서 계속 의문이 들었다. 최적화는 최적화인데 대체 어떻게 쿼리가 DB서버까지 가서 실행이 되고 쿼리가 실행이 되면 어떻게 이게 왜 최적화인지 궁금했다. 솔직히 아직까지는 잘모르겠다.
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/82848ff1-f2ae-4d4a-b5b9-5de5ae41a80b/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그림에는 없지만 Web Application Server 왼쪽 부분에는 WebServer가 있으며 이 Web Server와 그림에 있는 Web Application Server, Db Server까지가 Server Side쪽이고 그 Web Server와 연결된 Http 로 통신하는 부분. 즉, 사용자쪽이 또 따로 있다. Client Side라 생각하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/4b3deef6-1191-4b0a-a0da-c56b457bc1fa/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;최근 생각날 때 마다 고민하면서 그린건데 솔직히 맞는지는 잘모르겠다. 서버엔진에서 그 받은 쿼리를 파싱하고 나서 스토리지 엔진은 &lt;strong&gt;인터페이스&lt;/strong&gt;와 같은 역할로 DISK에 통신을 하는 것으로 알고 있다.&lt;/p&gt;
&lt;p&gt;즉, 나는 왜 이런 고민을 하냐면 인덱스에 대한 최적화를 공부하면서 최대한 DB에 적게 접근을 해야한다고 배웠고 그게 과연 Web Application Server에서 DB Server의 네트워크를 말하는건지 아니면 DB Server에서의 서버엔진에서 DISK로 가는 그러한 접근을 말하는 건지 이해를 할 수가 없었다.&lt;/p&gt;
&lt;p&gt;또 좀더 얘기를 해보자면 어떻게 보면 우리가 보는 쿼리는 고급언어이다. 이 고급언어를 TCP/IP로 통신을 하고 packet으로 오버헤드를 붙인 다음 프록시에 들렸다가 다시 DB Server로 쏘고 이제 여기서 MySQL 시스템이 있으며 여기에 서버엔진, 스토리지엔진이 있다고 생각하며 여기에 또한 데이터가 있는 DISK가 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;그럼 이제 좀 더 나아가면 클러스터 인덱스 같은 경우에는 leaf 부분에 데이터가 이미 있기 때문에 이 DISK에 가지 않고 그렇기에 이 성능이 좋아진다는 것으로 이해하고 있다.&lt;/p&gt;
&lt;p&gt;즉, 지금 나의 머리가 복잡한 이유가 이 과정이다. 아니 이게 과연 인덱스가 필요로 한다고? 겨우 이걸로? 라는 생각으로 부터 지금 내가 생각하는 이 데이터 흐름이 과연 맞는지. 나는 이러한 생각들로 이 원론적인 부분에 들어가려한다. 물론 아직 책을 읽기 전이지만 답이 나올 것 같지는 않다. 답을 내려고 하는 것은 아니다. 물론 답이 나온다면 좋다. 이 포스팅은 나의 머리에 있는 지금 여러 흐름들을 정리하고자 쓰는 글이라고 생각하면 좋다.&lt;/p&gt;
&lt;h2 id=&quot;mysql은-전체적으로-어떻게-생겼나&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql%EC%9D%80-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%83%9D%EA%B2%BC%EB%82%98&quot; aria-label=&quot;mysql은 전체적으로 어떻게 생겼나 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MySQL은 전체적으로 어떻게 생겼나?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버엔진&lt;/strong&gt;, &lt;strong&gt; 스토리지 엔진&lt;/strong&gt; 이 두가지를 알아야한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서버엔진 : 클라이언트의 요청을 받아 SQL을 처리하는 DB 자체의 기능적인 역할&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;스토리지 엔진 : 서버 엔진이 필요한 데이터를 물리 장치에서 가져오는 역할을 한다.&lt;/p&gt;
&lt;p&gt;자. 책에서 읽어보고 이해를 했을 때, 스토리지 엔진에서 DISK(물리 장치)에서 실제 데이터를 갖고 오는 것이 맞다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/bdf47a05-b5e3-4577-9cea-b36a086da38b/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;우선 여기까지는 내가 생각했던 것과 같다. 이 &lt;strong&gt;서버엔진&lt;/strong&gt;은 DB가 SQL을 이해할 수 있도록 쿼리를 재구성하는 쿼리 파싱, 디스크나 메모리 같은 물리적인 저장장치와 통신하는 스토리지 엔진에 데이터를 요청하는 업무를 담당한다. 즉, 이 말을 조금 더 풀어서 생각하자면 &lt;strong&gt;스토리지 엔진&lt;/strong&gt;이 데이터를 통신하기 위한 API 역할을 한다고 생각하면 쉬울 것 같다. 이것 또한 내가 생각했던 것과 같다.&lt;/p&gt;
&lt;p&gt;이제 여기서 가장 중요한 말을 하고 싶다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;스토리지 엔진에서 받아온 데이터를 사용자 요청에 맞게 처리하고 접근 제어, 쿼리 캐시, 옵티마이저 등의 역할을 수행한다. 사용자와 MySQL 사이에서 발생하는 데이터 처리 프로세스를 전부 담당한다고 생각하면 된다. &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이해가 되는가? 조금 더 이해하기 쉽도록 예를 보여주자면 Jojn, Group By, Order By, Function/Procedure, Trigger 와 같은 것 또한 &lt;strong&gt;서버엔진&lt;/strong&gt;에서 모두 맡아서 한다고 생각하면 된다.&lt;/p&gt;
&lt;p&gt;이제 서버엔진을 봤으니 &lt;strong&gt;스토리지 엔진&lt;/strong&gt;을 볼 차례다. 이 스토리지 엔진은 &lt;strong&gt;물리적인 저장장치에서 테이터를 읽어오는 역할&lt;/strong&gt;을 한다. 이게 되게 웃긴 것은 다른 DBMS와는 다르게 플러그인 처럼 작동하기 때문에 여러 종류의 스토리지 엔진을 간단하게 설치하여 바로 사용할 수 있다. 예를 들면 InnoDB, MyISAM과 같은 엔진이 있다.&lt;/p&gt;
&lt;h2 id=&quot;mysql에서-스토리지-엔진이란-무엇인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql%EC%97%90%EC%84%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;mysql에서 스토리지 엔진이란 무엇인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MySQL에서 스토리지 엔진이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;MySQL은 이러한 다양한 엔진으로 부터 다른 DBMS보다도 강력하다고 할 수 있다. 확장성과 유연함에서 말이다. 우리는 다른 엔진보다도 InnoDB를 엔진을 많이쓴다. 이유는 무엇일까?&lt;/p&gt;
&lt;p&gt;InnoDB는 &lt;strong&gt;MySQL에서 유일하게 트랜잭션을 지원하는 스토리지 엔진이다.&lt;/strong&gt; 그렇기에 많이 쓴다. 또한 그 경쟁자 MyISAM 같은 경우는 인덱스만 메모리에 올리지만 &lt;strong&gt;InnoDB는 인덱스와 데이터를 모두 올린다는 것이 가장 성능에 차이가 있다는 것&lt;/strong&gt;. 즉, InnoDB_Buffer_Pool_Size가 DB성능에 큰 영향을 주기도 한다.&lt;/p&gt;
&lt;p&gt;그럼 너무나도 당연한게 InnoDB에서는 클러스터 인덱스를 사용할 수 있지만 MyISAM같은 경우는 클러스터 인덱스를 지원하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Archive 스토리지 엔진&lt;/strong&gt;??
나는 이 책을 읽으면서 처음으로 들어본 엔진이다. 책을 읽으면서 너무 쓸데없는 부분이 있거나 쓰지 않는 엔진같은 경우 정리를 하지 않지만 이 엔진 같은 경우에는 나중에라도 한번은 쓸 수 있을 것같아서 정리를 한다. 이 엔진 같은 경우에는 &lt;strong&gt;로그 수집에 적합한 스토리지 엔진&lt;/strong&gt;이다.  데이터가 메모리상에서 압축되고 !! 이 상태로 디스크에 저장되기에 행 단위 잠금이 가능하고 UPDATE, DELETE를 사용할 수 없기 때문에 굉장히 로그와 같은 통계 프로젝트에 적합하다. 즉, 압축을 하므로 디스크에 대한 용량 또한 많이 줄일 수 있어서 좋다.&lt;/p&gt;
&lt;h2 id=&quot;mysql은-데이터를-어떻게-처리-할까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql%EC%9D%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B2%98%EB%A6%AC-%ED%95%A0%EA%B9%8C&quot; aria-label=&quot;mysql은 데이터를 어떻게 처리 할까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MYSQL은 데이터를 어떻게 처리 할까?&lt;/h2&gt;
&lt;p&gt;MySQL은 SQL을 병렬 처리하지 않는다... 음.. 우선 병렬처리는 하지 않는다. 모든 SQL을 단일 코어에서 처리한다.&lt;/p&gt;
&lt;p&gt;우선 팩트만 말하면 &lt;strong&gt;MySQL 입장에서는 CPU 코어 개수를 늘리는 Scale-Out 보다는 단위 처리량이 좋은 CPU로 Scale-Up 하는 것이 훨씬 좋다.&lt;/strong&gt; 이게 팩트다.&lt;/p&gt;
&lt;p&gt;MySQL의 Join은 항상 &lt;strong&gt;Nested Loop Join&lt;/strong&gt; 알고리즘으로 처리한다.
이러한 Nested Loop Join 같은 경우에는 처리할 데이터가 적어지면 수행 속도가 빠르지만 테이블 A나 테이블 B 중 하나라도 연산해야 할 데이터가 많아지면 쿼리 효율이 기하급수적으로 떨어진다.&lt;/p&gt;
&lt;p&gt;이제 여기서 내가 알고 있던 지식은 드라이빙 테이블에서 드라이븐 테이블로 접근할 때, 드라이븐 테이블에서 인덱스가 없으면 풀스캔이 난다는 지식만 알고 있었고 만약 그렇지 않으면 풀스캔을 한다는 것만 알고 있었다. 이 책을 읽어보고 여기서 조금 더 추가를 하자면 3개의 for 반복문이 있고 하나의 테이블이 더 생성되며, 만약 드라이븐 테이블에서 마땅한 index가 없으면 3번째 테이블을 이용한 풀스캔을 한다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;그리고 조금 더 나아가자면 &lt;strong&gt;Block Nested Loop Join&lt;/strong&gt;을 알았다. 즉, DB 내부에서 조금 더 성능을 높이기 위해서 테이블 조인 시 필요한 데이터를 일시적으로 메모리에 저장하여 효율적으로 데이터에 접근하는 것!&lt;/p&gt;
&lt;p&gt;우선 이 부분은 읽어봐도 이해가 되지는 않지만, 드라이븐 테이블에 접근하는 빈도수를 더 적게 해주면서 성능이 좋아지는 것같다.&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B0&quot; aria-label=&quot;마치며 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치며&lt;/h2&gt;
&lt;p&gt;오늘 쉬는 날이기도 해서 가볍게 DB에 대한 책을 읽어보기 시작했다. 이 책은 작다. 그리고 페이지수도 적다. 출, 퇴근 시간에 버스에서 읽으려고 했는데 멀미가 나서 그 동안 읽지 못했다. 무튼.. 결론은 굉장히 작은 책이지만 재밌었다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt; : 실무 예제로 다가가는 MySQL 쿼리작성 MySQL 퍼포먼스 최적화 - 성동찬, 한빛미디어&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item><item><title><![CDATA[Where 조건에 대한 이해]]></title><description><![CDATA[시작 where…]]></description><link>https://gb-template.netlify.com/lke20210630/</link><guid isPermaLink="false">https://gb-template.netlify.com/lke20210630/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Wed, 30 Jun 2021 22:31:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;where 조건문을 그냥 쓰지말자. 알고 쓰자.&lt;/p&gt;
&lt;h2 id=&quot;묵시적-형변환-함정에-빠지지-말기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AC%B5%EC%8B%9C%EC%A0%81-%ED%98%95%EB%B3%80%ED%99%98-%ED%95%A8%EC%A0%95%EC%97%90-%EB%B9%A0%EC%A7%80%EC%A7%80-%EB%A7%90%EA%B8%B0&quot; aria-label=&quot;묵시적 형변환 함정에 빠지지 말기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;묵시적 형변환 함정에 빠지지 말기&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;묵시적 형변환&lt;/strong&gt;. 조건절의 데이터 타입이 다를 때, 우선 순위가 높은 타입으로 형이 내부적으로 변환되는 것을 말하는 데 이게 개발자들이 모르면서 그냥 넘어가는 경우가 많다. 묵시적으로 변환을 해주기 때문에.&lt;/p&gt;
&lt;p&gt;예를 들어, 문자열과 정수값을 비교한다고 하면 당연히 두 타입을 똑같은 형으로 변환을 시키고 비교를 해야하므로 문자열이 정수로 또는 정수가 문자열로 변환이 되어야한다. 현재 우선순위로는 정수 타입이 문자열보다 높으므로 자연스럽게 문자열 타입이 정수 타입으로 묵시적으로 변환이 된다.&lt;/p&gt;
&lt;p&gt;우리는 &lt;strong&gt;인덱스&lt;/strong&gt;라는 것을 쓰면서 풀스캔을 방지한다. &apos;친절한 SQL 튜닝&apos;이라는 책에서도 나왔지만 이 &lt;strong&gt;인덱스에 대한 필드가 형변환이 내부적으로 일어나면 범위를 좁히지 못하고 풀스캔을 하는 경우가 발생&lt;/strong&gt;한다.&lt;/p&gt;
&lt;p&gt;자. 생각해보자. 그럼 우선 순위가 정수 타입이 높으므로 문자열을 넣는다 해도 정수형이 필요하면 묵시적으로 정수형으로 형변환이 되기 때문에 귀찮음이 많은 개발자라면 &apos;문자열&apos;을 넣어주면 괜찮다.&lt;/p&gt;
&lt;p&gt;다만, whitespace라던가 예기치못한 상황이 올수도 있으므로 생각하며 형에 맞춰서 질의를 해주자.&lt;/p&gt;
&lt;p&gt;( + 성능 테스트하는 법 : 28 page 참고 )&lt;/p&gt;
&lt;h2 id=&quot;편리한-함수-잘못-쓰면-성능에-독이-된다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8E%B8%EB%A6%AC%ED%95%9C-%ED%95%A8%EC%88%98-%EC%9E%98%EB%AA%BB-%EC%93%B0%EB%A9%B4-%EC%84%B1%EB%8A%A5%EC%97%90-%EB%8F%85%EC%9D%B4-%EB%90%9C%EB%8B%A4&quot; aria-label=&quot;편리한 함수 잘못 쓰면 성능에 독이 된다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;편리한 함수, 잘못 쓰면 성능에 독이 된다&lt;/h2&gt;
&lt;p&gt;각 DBMS는 내장된 함수를 제공하고 사용자 정의함수도 제공하기에 빈번하게 사용한다. 하지만 이러한 함수가 시스템 부하를 야기한다. 우리의 DB튜닝 목표 중 하나 DBMS가 이해하기 쉽게 SQL을 작성하는 것도 포함이 된다.&lt;/p&gt;
&lt;p&gt;우리는 적절한 인덱스, 테이블 파티셔닝을 통해 데이터를 빨리 찾을 수 있다는 팩트를 알고 있다.&lt;/p&gt;
&lt;p&gt;예를 들어보자. DATE_FORMAT 이라는 내장 함수가 있다. 그리고 우리는 cumlative_time 이라는 필드로 인덱스를 걸었다. 과연, 이 DATE_FORMAT을 쓰면 옵티마이저가 cumlative_time의 데이터 분포도를 알 수 있을까? &lt;strong&gt;알지 못한다.&lt;/strong&gt; 이게 문제다. DATE_FORMAT &lt;strong&gt;내장 함수로 인해 변경될 결과값을 옵티마이저가 예상하지 못하기 때문이다.( 데이터 분포도 )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;또한, 이러한 상황이 아니더라도 이 내장 함수를 한 쿼리에 여러번 사용하다보면 시스템적으로 부하가 일어난다 . ( 직관적으로 생각했을 때, 느낌이 오죵? )&lt;/p&gt;
&lt;p&gt;즉, 나의 결론을 말하자면 이 함수는 고급언어라고 생각한다. 무슨 말이냐면 DBMS가 이해하기 쉬운 언어가 아니라 개발자, 사용자가 사용하기 쉬운 언어라는 것이다. &lt;strong&gt;우리는 성능이 좋게 튜닝하는 것이 목적이기에 우리가 보기 좋은 것보다는 DBMS가 읽기 쉬운 언어로 쿼리를 짜야한다.&lt;/strong&gt; DB 입장에서 SQL을 작성하자.&lt;/p&gt;
&lt;h2 id=&quot;like-검색을-아무-때나-써야-하나&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#like-%EA%B2%80%EC%83%89%EC%9D%84-%EC%95%84%EB%AC%B4-%EB%95%8C%EB%82%98-%EC%8D%A8%EC%95%BC-%ED%95%98%EB%82%98&quot; aria-label=&quot;like 검색을 아무 때나 써야 하나 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;LIKE 검색을 아무 때나 써야 하나?&lt;/h2&gt;
&lt;p&gt;데이터를 조회할 때 특정 단어가 들어 있는 데이터를 검색하기 위해 LIKE 를 쓴다. 우선 팩트부터 말하자면 &lt;strong&gt;대용량 테이블일 경우 위험.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;또 정말 중요한 팩트부터 얘기하자면 인덱스는 데이터가 위치한 곳을 지칭한다. ( + 커버링, 클러스터 같은 경우 지칭을 떠나 그 자체로 데이터가 됨)  또한, 실 데이터에 대한 데이터를 다시 읽어야 하기 때문에 중복된 데이터 처리 비용보다는 테이블 풀스캔으로 접근하는 것이 훨씬 빠르다고 옵티마이저가 상황에 따라 판단한다.&lt;/p&gt;
&lt;p&gt;또한 &lt;strong&gt;인덱스는 메모리도 차지하며 디스크를 소모하고 CPU 연산이 필요한 데이터이다. 즉, 장점만 있는 것이 아니라는 것을 알자.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중요 !&lt;/strong&gt;
이 LIKE 같은 경우도 만약 필드가 인덱스에 걸려있다면, &apos;%&apos;위치에 따라서 의미가 있을 수도 또는 없을 수도 있다. 즉, 아이디인 &quot;ggomjae&quot; 를 예를 들어보면 이 아이디 필드가 &quot;ggom%&quot;일 경우에는 인덱스를 탄다. 왜? g 부터 데이터의 시작점을 찾으니까. 근데 만약 &quot;%omjae&quot; 일 경우에는 아무리 아이디 필드가 인덱스여도 타지 않는다. 그 기준점이 모호하기 때문이다. 즉, 인덱스임에도 불구하고 풀스캔을 때린다.&lt;/p&gt;
&lt;p&gt;여기까지는 익히 알고 있었던 지식인데 책을 읽으면서 &apos;아! &apos; 했던 부분이 아무리 앞부분이 살아있다고 하더라도 옵티마이저가 데이터 분포도를 확인했을 때, 전체 데이터의 &lt;strong&gt;20%이상&lt;/strong&gt;이 분포되어있다고 판단했을 때, 인덱스가 아닌 &lt;strong&gt;풀스캔&lt;/strong&gt;을 때려버린다.&lt;/p&gt;
&lt;p&gt;이유는 20% 이상이 넘어가면 인덱스를 읽고 다시 데이터 파일로 갈게 아니라 처음 부터 데이터 파일을 읽는게 빠르다고 생각하기 때문이다.&lt;/p&gt;
&lt;p&gt;책의 LIKE 부분 마지막 챕터에 중요한 결론이 나오는 데 정리하자면, &lt;strong&gt;LIKE 조건이 &apos;검색어%&apos;와 같은 경우 데이터 분포도에 따라 옵티마이저가 판단하며 보편적으로 20%가 넘어가면 풀스캔을 때린다.&lt;/strong&gt; 만약, 앞부분이 아니라 뒷부분 &lt;strong&gt;&apos;%검색어&apos;와 같다면 LIKE가 아닌 다른 조건도 더 붙여서 데이터 범위를 최대한 줄이도록 해보자.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;마치며&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B0&quot; aria-label=&quot;마치며 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치며&lt;/h2&gt;
&lt;p&gt;이 책은 나에게 굉장히 좋은 점이다. &apos;친절한 SQL 튜닝&apos;을 아직 다 읽지는 않았지만 어느 정도 읽은 상태에서 이 책을 보니까 굉장히 조각처럼 있는 지식들이 한곳에 뭉쳐서 정확한 지식이 되는 느낌이다. 조금의 물질적인 것과 접착제같은 느낌이랄까. 즉, DBMS에 대해서 처음 공부를 하는 사람이면 좋다고 생각하지 못할 것이다. 얇은 만큼 설명이 굉장히 축소되어있기 때문이다. 무튼, 이번 챕터도 굉장히 얻어가는 게 많은 챕터였다. 좋다!!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt; : 실무 예제로 다가가는 MySQL 쿼리작성 MySQL 퍼포먼스 최적화 - 성동찬, 한빛미디어&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item><item><title><![CDATA[Cluster Index vs Non-Cluster Index 이론 및 성능 비교 ( JPA + MYSQL )]]></title><description><![CDATA[시작 나는 항상 Auto-Increment를 이용해서 PK를 넣었다. 하지만 이번에 통계 프로젝트를 하면서 Auto_Increment가 아닌 PK에 Time, name을 PK로 설정을 했다. 그 이유는 명료하다. Auto_Increment 로 PK를 설정하는 것보다 Cluster Index…]]></description><link>https://gb-template.netlify.com/clusterindex20210629/</link><guid isPermaLink="false">https://gb-template.netlify.com/clusterindex20210629/</guid><category><![CDATA[mysql]]></category><category><![CDATA[db]]></category><pubDate>Mon, 28 Jun 2021 20:31:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;시작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91&quot; aria-label=&quot;시작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;시작&lt;/h2&gt;
&lt;p&gt;나는 항상 Auto-Increment를 이용해서 PK를 넣었다. 하지만 이번에 통계 프로젝트를 하면서 Auto_Increment가 아닌 PK에 Time, name을 PK로 설정을 했다. 그 이유는 명료하다. Auto_Increment 로 PK를 설정하는 것보다 Cluster Index로 설정을 하는 것이 성능에 좋다는 것을. 물론 무조건 장점만 있다면 무엇이든 Cluster Index로 설정을 하겠지만 여러가지 경우의 수를 생각해야하며 Auto_Increment가 아닌 유동적인 Column을 이용한 PK로 설정하면 나중 생각지도 못한 경우로 DB 스키마 자체를 뜯어내야하기 때문에 좀 더 신경써서 설정을 해야한다. 간단하게 설명하고 싶다. 이해하기 어려웠기에.&lt;/p&gt;
&lt;h2 id=&quot;non-cluster-index&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#non-cluster-index&quot; aria-label=&quot;non cluster index permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Non Cluster Index&lt;/h2&gt;
&lt;p&gt;Non Cluster Index는 우리가 흔히 쓰는 인덱스다. 보통은 Auto-Increment로 PK를 설정하고 데이터를 찾고자 할 때, 빨리 찾기 위해 정렬을 위한 Index를 설정 하는 것이 Non Cluster Index이다. 이 인덱스는 여러개 생성을 할 수 있다.&lt;/p&gt;
&lt;p&gt;생각해보자. 우리는 인덱스가 무엇인지 알고 있다. 흔히 설명하는 색인 또는 찾아보기목록. 그렇다. 우리가 책을 읽고 맨 앞 그리고 맨 뒤에 &lt;strong&gt;찾아보기&lt;/strong&gt; 이게 바로 Non Cluster Index다. 우리가 매일 말하는 인덱스는 어떻게보면 항상 자연스럽게 Non Cluster Index를 얘기하고 있는 것.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/418b68ec-88e6-40e0-840b-8dd208d805d9/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;그림을 보면 이해하기가 쉽다. 현재 8을 찾고자한다. Index가 있다는 것은 무조건 그 기준으로 정렬이 되있다는 뜻이다. 즉, 인덱스 테이블이 여러개 있다. 그림을 보면 그 중간이 임시 테이블이며 인덱스 테이블이다. 인덱스 테이블을 보면 그 값이 있는 것이 아니라 또 &lt;strong&gt;3페이지 -2&lt;/strong&gt; 라는 주소값을 갖게 된다. 그리고 그 주소값을 향해 찾아가면 데이터가 있다. 현재 중간에 있는 것이 Leaf 인덱스다. 그리고 그 Leaf 인덱스 값에는 그 데이터 값 자체가 있는 것이 아닌 데이터가 있는 주소값을 갖고있다.&lt;/p&gt;
&lt;p&gt;현재 Dept 이 1밖에 안되서 그렇지 좀 더 Dept이 있다고 가정해보면 이 왼쪽에서 오른쪽으로 가는 과정들이 각 각의 값들이 주소값이며 이것을 수직적 탐색이라고 한다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/4e29caab-13b6-4a20-8125-3b4d0277bad5/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;친절한 SQL에 있는 하나의 예시다. 오른쪽 그림을 보면 인덱스라는 dept에 수직적으로 스캔을 하고 마지막으로 수평 스캔을 한다음 각 ROWID를 얻고 데이터 테이블에 랜덤엑세스를 한다.&lt;/p&gt;
&lt;p&gt;책의 내용에 이런 문장이 있다. &lt;strong&gt;수평적인 스캔을 하는 이유 ?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫째, 조건절을 만족하는 데이터를 모두 찾기 위해&lt;/li&gt;
&lt;li&gt;둘째, ROWID를 얻기 위해&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 ROWID란, 데이터가 있는 테이블에 주소값이라고 생각하면 된다.
이게 바로 우리가 매일 사용하고 있는 인덱스며 Non Cluster Index 이다.&lt;/p&gt;
&lt;h2 id=&quot;cluster-index&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cluster-index&quot; aria-label=&quot;cluster index permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Cluster Index&lt;/h2&gt;
&lt;p&gt;Non Cluster Index를 이해했으면 쉽게 Cluster Index를 이해할 수 있을 것이다. 그 이유는
테이블 자체가 클러스터드 인덱스의 리프 노드(leaf node)로서 기능하기 때문에 쉽다. 즉, Non Cluster Index의 leaf node는 이 데이터를 찾기 위해 ROWID를 갖고 데이터를 찾아야했다.
하지만 Cluster Index는 이 leaf node에 데이터 값이 있기 때문에 시간이 절약되며 훨씬 빠르게 찾을 수 있다는 것이 장점이다.&lt;/p&gt;
&lt;p&gt;물론 단점도 있다. Insert Data 를 할 때 단점이 있다. 이유는 Non Cluster Index처럼 따로 인덱스를 관리하는 것이 아닌 Cluster Index는 물리적인 즉, 그 자체로 정렬을 하기 때문에 Insert Data를 할 때, 정렬에 맞게 끔 insert를 해야하므로 이부분에서는 Non Cluster Index보다 성능이 좋지 않다.&lt;/p&gt;
&lt;p&gt;그럼 여기서 결론을 내릴 수 있다. Cluster Index는 insert Data 보다는 Read를 하는 프로젝트일 때 좋은 선택지다. 예를 들자면 Batch Module로 통계에 대한 값들을 주기적으로 DB에 넣고 API Module로 그 값들을 읽어 드리는 프로젝트 일 경우는 적합하다.&lt;/p&gt;
&lt;h2 id=&quot;직접-확인하기-cluster-index-vs-non-cluster-index---1-jpa에-대한-구현&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A7%81%EC%A0%91-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-cluster-index-vs-non-cluster-index---1-jpa%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B5%AC%ED%98%84&quot; aria-label=&quot;직접 확인하기 cluster index vs non cluster index   1 jpa에 대한 구현 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;직접 확인하기 Cluster Index vs Non Cluster Index - 1 JPA에 대한 구현&lt;/h2&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/ede1d587-3185-471e-9d48-d016bb23e173/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;NonClusterIndex 같은 경우에는 보통 우리가 했던 GenerationType.IDENTITY를 이용하여 구현하였고 ClusterIndex 같은 경우에는 @EmbeddedId를 이용하여 구현하였다.&lt;a href=&quot;https://velog.io/@ggomjae/GenerationType.IDENTITY-GenerationType.AUTO-%EC%B0%A8%EC%9D%B4&quot;&gt;AUTO를 쓰지 않은 이유&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;직접-확인하기-cluster-index-vs-non-cluster-index---2-10만개-더미데이터를-이용한-성능-확인&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A7%81%EC%A0%91-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-cluster-index-vs-non-cluster-index---2-10%EB%A7%8C%EA%B0%9C-%EB%8D%94%EB%AF%B8%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%84%B1%EB%8A%A5-%ED%99%95%EC%9D%B8&quot; aria-label=&quot;직접 확인하기 cluster index vs non cluster index   2 10만개 더미데이터를 이용한 성능 확인 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;직접 확인하기 Cluster Index vs Non Cluster Index - 2 10만개 더미데이터를 이용한 성능 확인&lt;/h2&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/0fb9db4d-5411-4410-b256-834e170aae6a/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;p&gt;각 차이점은 cluster_index_entity는 pk 즉, cluster index를 이용하여 값을 구하고 non_clusterindex_entity는 non cluster index를 이용하여 값을 구한다는 것이다.
그리고 결과적으로 Query Cost에 대한 차이가 있다.&lt;/p&gt;
&lt;h2 id=&quot;index에-대한-우리가-가져가야할-생각&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#index%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9A%B0%EB%A6%AC%EA%B0%80-%EA%B0%80%EC%A0%B8%EA%B0%80%EC%95%BC%ED%95%A0-%EC%83%9D%EA%B0%81&quot; aria-label=&quot;index에 대한 우리가 가져가야할 생각 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Index에 대한 우리가 가져가야할 생각&lt;/h2&gt;
&lt;p&gt;친절한 SQL책을 읽어보면서 좋은 표현이라고 해야하나.. 좋은 문장이 많다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인덱스를 정상적으로 사용한다
인덱스를 정상적으로 사용한다는 것은 &lt;strong&gt;리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔을 하다가 중간에 멈추는 것&lt;/strong&gt; 이라고 한다. 즉, 나의 생각은 수직적인 스캔을 하고 ROWID를 찾는 과정 또는 데이터를 찾는 과정에서 적절하게 범위를 조절하는 것이 인덱스를 제대로, 정상적으로 사용한다고 하는 말 같다. 만약, 이 적절한 범위를 찾지 못하거나 인덱스를 잘못걸어준다면 우리가 가장 꺼려하는 (물론 손익분기점에 따른 예외도 있지만) Index FullScan방식으로 작동을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인덱스를 사용하는 이유는 &lt;strong&gt;정렬&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인덱스 스캔을 하는 이유는 &lt;strong&gt; 소량의 데이터를 빨리 찾고 ROWID를 얻기 위해&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수직적 탐색은 &lt;strong&gt;인덱스 스캔 시작지점을 찾는 과정&lt;/strong&gt;
수평적 탐색은 &lt;strong&gt;데이터를 찾는 과정&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인덱스 손익분기점 이 그래프의 5% ~ 20%는 10만에서 100만건정도의 수치고 1000만건 등의 큰 수치일 수록 이 손익분기점은 내려간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/578ed161-bc43-45b0-9577-bbefd30c2345/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
&lt;h2 id=&quot;끝내며&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%81%9D%EB%82%B4%EB%A9%B0&quot; aria-label=&quot;끝내며 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;끝내며&lt;/h2&gt;
&lt;p&gt;나는 이번 신입 사원 프로젝트로 후후 통계 프로젝트를 했다. Spring Batch를 이용하여 통계낸 것을 Api Module에서 통계값을 가져와 통계 그래프와 결과를 보여주는 프로젝트다. 이러한 프로젝트를 통해서 Non Cluster Index, Cluster Index를 알았고 그 과정속에서 Index에 대한 깊이를 조금은 들어왔다고 생각한다. 굉장히 배울점이 많아서 좋았던 프로젝트였고 더 나아가 Group By에 대한 이슈가 있었으므로 그 부분또한 추후에 포스팅을 할 예정이다.&lt;/p&gt;
&lt;p&gt;2021-05-11 : 커버링 vs 클러스터 차이 추가
&lt;img src=&quot;https://images.velog.io/images/ggomjae/post/7f4a834f-689f-4cdd-be10-9b563d130503/image.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</content:encoded><author>a_l_b_bloomer@naver.com</author></item></channel></rss>